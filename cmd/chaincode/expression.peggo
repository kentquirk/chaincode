{
    package main
}

File <- Expr EOL EOF

Expr <-
    ( NumericExpr
    / BooleanExpr
    )

NumericExpr <- first:Term _? rest:(AddOp _? Term)*

Term <- first:Factor _? rest:(MulOp _? Factor)*

Factor <-
    ( '(' _? NumericExpr _? ')'
    / n:NumericValue
    )

BooleanExpr <- first:Conjunction _? rest:(OrOp _? Conjunction)*

Conjunction <- first:BValue _? rest:(AndOp _? BValue)*

BValue <-
    ( '(' _? BooleanExpr _? ')'
    / b:BooleanValue
    / Comparison
    )

// by splitting this up we can make the compiler check that the types on both sides are the same
Comparison <-
    ( BooleanExpr _? ComparisonOp _? BooleanExpr
    / NumericExpr _? ComparisonOp _? NumericExpr
    )

NumericValue <-
    ( DecimalInteger
    / HexInteger
    / NumericName
    / NumericExpr
    )

BooleanValue <-
    ( Boolean
    / BooleanName
    )

NumericName <- n:Name                                   { return n.(string), nil }
Name <- [A-Za-z] [A-Za-z0-9_]*                          { return string(c.text), nil }

AddOp <- ( '+' / '-' )                                  { return string(c.text), nil }
MulOp <- ( '*' / '/' / '%' )                            { return string(c.text), nil }
OrOp <- "or"                                            { return string(c.text), nil }
AndOp <- "and"                                          { return string(c.text), nil }
ComparisonOp <- ( "==" / "!=" / ">=" / "<=" / '<' / '>' )   { return string(c.text), nil }

DecimalInteger <- '-'? [0-9]+                           { return string(c.text), nil }
HexInteger <- "0x" [0-9a-fA-F]+                         { return string(c.text), nil }
Boolean <- ( "true" / "false" )                         { return string(c.text), nil }

_ <- [ \t]+
Comment <- "//" [^\r\n]*

EOL <- _? Comment? ("\r\n" / "\n\r" / "\r" / "\n" )
EOF <- !.
