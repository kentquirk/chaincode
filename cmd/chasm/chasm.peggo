{
    package main

}

Script <- EOL* p:Preamble code:Code EOF { return newScript(p, code) }

Preamble <-  _? "context" _? ":" _? cc:ContextConstant EOL { return newPreambleNode(cc.(vm.ContextByte)) }

Code <-  EOL* f:FunctionDef+ { return f, nil }

FunctionDef <- _? "func" _ n:FunctionName _? '{' s:Line+ _? '}' EOL*  {
        fm := c.globalStore["functions"].(map[string]int)
        name := n.(string)
        ctr := c.globalStore["functionCounter"].(int)
        fm[name] = ctr
        ctr++
        c.globalStore["functionCounter"] = ctr
        return newFunctionDef(name, s)
    }

Line <-
    ( _? op:Operation EOL { return op, nil }
    / EOL { return nil, nil }
    )

Operation <-
    ( ConstDef
    / Opcode
    )

ConstDef <-
    ( k:Constant _? '=' _? v:Value {
            if key, ok := k.(string); ok {
                cm := c.globalStore["constants"].(map[string]string)
                cm[key] = v.(string)
                return v, nil
            }
            return nil, errors.New("Bad const def")
        }
    )

// note that opcodes that are spelled as a prefix of some other one
// like push and push64 need to have the longer one first, as this
// construct tests in order
Opcode =
    ( "nop" { return newUnitaryOpcode(vm.OpNop) }
    / "drop2" { return newUnitaryOpcode(vm.OpDrop2) }
    / "drop" { return newUnitaryOpcode(vm.OpDrop) }
    / "dup2" { return newUnitaryOpcode(vm.OpDup2) }
    / "dup" { return newUnitaryOpcode(vm.OpDup) }
    / "swap" { return newUnitaryOpcode(vm.OpSwap) }
    / "over" { return newUnitaryOpcode(vm.OpOver) }
    / "pick" _ b:Byte { return newBinaryOpcode(vm.OpPick, b.(string)) }
    / "roll" _ b:Byte { return newBinaryOpcode(vm.OpRoll, b.(string)) }
    / "ret" { return newUnitaryOpcode(vm.OpRet) }
    / "fail" { return newUnitaryOpcode(vm.OpFail) }
    / "zero" { return newUnitaryOpcode(vm.OpZero) }
    / "false" { return newUnitaryOpcode(vm.OpFalse) }
    / "push64" _ v:Value  { return newPush64(v.(string)) }
    / "push" _ v:Value  { return newPushOpcode(v.(string)) }
    / "one" { return newUnitaryOpcode(vm.OpOne) }
    / "true" { return newUnitaryOpcode(vm.OpTrue) }
    / "neg1" { return newUnitaryOpcode(vm.OpNeg1) }
    / "pusht" _ ts:Timestamp  { return newPushTimestamp(ts.(string)) }
    / "pushl" { return newUnitaryOpcode(vm.OpPushL) }
    / "now" { return newUnitaryOpcode(vm.OpNow) }
    / "rand" { return newUnitaryOpcode(vm.OpRand) }
    / "add" { return newUnitaryOpcode(vm.OpAdd) }
    / "sub" { return newUnitaryOpcode(vm.OpSub) }
    / "mul" { return newUnitaryOpcode(vm.OpMul) }
    / "div" { return newUnitaryOpcode(vm.OpDiv) }
    / "mod" { return newUnitaryOpcode(vm.OpMod) }
    / "not" { return newUnitaryOpcode(vm.OpNot) }
    / "neg" { return newUnitaryOpcode(vm.OpNeg) }
    / "inc" { return newUnitaryOpcode(vm.OpInc) }
    / "dec" { return newUnitaryOpcode(vm.OpDec) }
    / "eq" { return newUnitaryOpcode(vm.OpEq) }
    / "gt" { return newUnitaryOpcode(vm.OpGt) }
    / "lt" { return newUnitaryOpcode(vm.OpLt) }
    / "index" { return newUnitaryOpcode(vm.OpIndex) }
    / "len" { return newUnitaryOpcode(vm.OpLen) }
    / "append" { return newUnitaryOpcode(vm.OpAppend) }
    / "extend" { return newUnitaryOpcode(vm.OpExtend) }
    / "slice" { return newUnitaryOpcode(vm.OpSlice) }
    / "fieldl" { return newUnitaryOpcode(vm.OpFieldL) }
    / "field" { return newUnitaryOpcode(vm.OpField) }
    / "choice" { return newUnitaryOpcode(vm.OpChoice) }
    / "wchoice" { return newUnitaryOpcode(vm.OpWChoice) }
    / "sort" { return newUnitaryOpcode(vm.OpSort) }
    / "lookup" { return newUnitaryOpcode(vm.OpLookup) }
    / "call" _ n:FunctionName _ b:Byte { return newCallOpcode(vm.OpCall, n.(string), b.(string)) }
    / "enddef" { return newUnitaryOpcode(vm.OpEndDef) }
    / "ifz" { return newUnitaryOpcode(vm.OpIfz) }
    / "ifnz" { return newUnitaryOpcode(vm.OpIfnz) }
    / "else" { return newUnitaryOpcode(vm.OpElse) }
    / "endif" { return newUnitaryOpcode(vm.OpEndIf) }
    / "sum" { return newUnitaryOpcode(vm.OpSum) }
    / "avg" { return newUnitaryOpcode(vm.OpAvg) }
    / "max" { return newUnitaryOpcode(vm.OpMax) }
    / "min" { return newUnitaryOpcode(vm.OpMin) }
    )

Timestamp <- ts:(Date 'T' Time 'Z') { return ts.(string), nil }
Date <- [0-9] [0-9] [0-9] [0-9] '-' [0-9] [0-9] '-' [0-9] [0-9]
Time <-  [0-9] [0-9] ':' [0:9] [0-9] '-' [0-9] [0-9]

ContextConstant <-
    ( "TEST" { return vm.CtxTest, nil }
    / "NODE_PAYOUT" { return vm.CtxNodePayout, nil }
    / "EAI_TIMING" { return vm.CtxEaiTiming, nil }
    / "NODE_QUALITY" { return vm.CtxNodeQuality, nil }
    / "MARKET_PRICE" { return vm.CtxMarketPrice, nil }
    )

Value =
    ( Integer
    / ConstantRef
    )

ConstantRef <- k:Constant                         { cm := c.globalStore["constants"].(map[string]string); return cm[k.(string)], nil }
Integer <- '-'? [0-9]+                            { return string(c.text), nil }
Byte <-
    ( "0x" [0-9A-Fa-f] [0-9A-Fa-f]?               { return string(c.text), nil }
    / [0-9]+                                      { return string(c.text), nil }
    )
Constant <- [A-Z] [A-Z0-9_]*                      { return string(c.text), nil }
FunctionName <- [A-Za-z] [A-Za-z0-9_]+            { return string(c.text), nil }


_ <- [ \t]+

EOL <- _? Comment? ("\r\n" / "\n\r" / "\r" / "\n" )

Comment <- ';' [^\r\n]*

EOF <- !.

