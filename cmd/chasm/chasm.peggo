{
    package main

}

Script <- EOL* p:Preamble code:Code EOF { return newScript(p, code) }

Preamble <-  _? "context" _? ":" _? cc:ContextConstant EOL { return newPreambleNode(cc.(byte)) }

Code <-  EOL* _? '{' s:Line+ _? '}' EOL* { return s, nil }

Line <-
    ( _? op:Operation EOL { return op, nil }
    / EOL { return nil, nil }
    )

Operation <-
    ( ConstDef
    / Opcode
    )

ConstDef <-
    ( k:Constant _? '=' _? v:Value {
            if key, ok := k.(string); ok {
                c.state[key] = v.(string)
                return v, nil
            }
            return nil, errors.New("Bad const def")
        }
    )

// note that opcodes that are spelled as a prefix of some other one
// like push and push64 need to have the longer one first, as this
// construct tests in order
Opcode =
    ( "nop" { return newUnitaryOpcode(OpNop) }
    / "drop2" { return newUnitaryOpcode(OpDrop2) }
    / "drop" { return newUnitaryOpcode(OpDrop) }
    / "dup2" { return newUnitaryOpcode(OpDup2) }
    / "dup" { return newUnitaryOpcode(OpDup) }
    / "swap" { return newUnitaryOpcode(OpSwap) }
    / "over" { return newUnitaryOpcode(OpOver) }
    / "ret" { return newUnitaryOpcode(OpRet) }
    / "fail" { return newUnitaryOpcode(OpFail) }
    / "zero" { return newUnitaryOpcode(OpZero) }
    / "false" { return newUnitaryOpcode(OpFalse) }
    / "push64" _? v:Value  { return newPush64(v.(string)) }
    / "push" _? v:Value  { return newPushOpcode(v.(string)) }
    / "one" { return newUnitaryOpcode(OpOne) }
    / "true" { return newUnitaryOpcode(OpTrue) }
    / "neg1" { return newUnitaryOpcode(OpNeg1) }
    / "pusht" _? ts:Timestamp  { return newPushTimestamp(ts.(string)) }
    / "now" { return newUnitaryOpcode(OpNow) }
    / "rand" { return newUnitaryOpcode(OpRand) }
    / "add" { return newUnitaryOpcode(OpAdd) }
    / "sub" { return newUnitaryOpcode(OpSub) }
    / "mul" { return newUnitaryOpcode(OpMul) }
    / "div" { return newUnitaryOpcode(OpDiv) }
    / "mod" { return newUnitaryOpcode(OpMod) }
    / "not" { return newUnitaryOpcode(OpNot) }
    / "neg" { return newUnitaryOpcode(OpNeg) }
    / "inc" { return newUnitaryOpcode(OpInc) }
    / "dec" { return newUnitaryOpcode(OpDec) }
    / "index" { return newUnitaryOpcode(OpIndex) }
    / "len" { return newUnitaryOpcode(OpLen) }
    / "append" { return newUnitaryOpcode(OpAppend) }
    / "extend" { return newUnitaryOpcode(OpExtend) }
    / "slice" { return newUnitaryOpcode(OpSlice) }
    / "fieldl" { return newUnitaryOpcode(OpFieldL) }
    / "field" { return newUnitaryOpcode(OpField) }
    / "choice" { return newUnitaryOpcode(OpChoice) }
    / "wchoice" { return newUnitaryOpcode(OpWChoice) }
    / "sort" { return newUnitaryOpcode(OpSort) }
    / "lookup" { return newUnitaryOpcode(OpLookup) }
    / "ifz" { return newUnitaryOpcode(OpIfz) }
    / "ifnz" { return newUnitaryOpcode(OpIfnz) }
    / "else" { return newUnitaryOpcode(OpElse) }
    / "end" { return newUnitaryOpcode(OpEnd) }
    / "sum" { return newUnitaryOpcode(OpSum) }
    / "avg" { return newUnitaryOpcode(OpAvg) }
    / "max" { return newUnitaryOpcode(OpMax) }
    / "min" { return newUnitaryOpcode(OpMin) }
    )

Timestamp <- ts:(Date 'T' Time 'Z') { return ts.(string), nil }
Date <- [0-9] [0-9] [0-9] [0-9] '-' [0-9] [0-9] '-' [0-9] [0-9]
Time <-  [0-9] [0-9] ':' [0:9] [0-9] '-' [0-9] [0-9]

ContextConstant <-
    ( "TEST" { return CtxTest, nil }
    / "NODE_PAYOUT" { return CtxNodePayout, nil }
    / "EAI_TIMING" { return CtxEaiTiming, nil }
    / "NODE_QUALITY" { return CtxNodeQuality, nil }
    / "MARKET_PRICE" { return CtxMarketPrice, nil }
    )

Value =
    ( Integer
    / ConstantRef
    )

ConstantRef <- k:Constant                         { return c.state[k.(string)], nil }
Integer <- '-'? [0-9]+                            { return string(c.text), nil }
Constant <- [A-Z] [A-Z0-9_]*                      { return string(c.text), nil }

_ <- [ \t]+

EOL <- _? Comment? ("\r\n" / "\n\r" / "\r" / "\n" )

Comment <- ';' [^\r\n]*

EOF <- !.

