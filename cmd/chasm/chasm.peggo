{
    package main

}

Script <- EOL* p:Preamble code:Code EOF { return newScript(p, code) }

Preamble <-  _? "context" _? ":" _? cc:ContextConstant EOL { return newPreambleNode(cc.(byte)) }

Code <-  EOL* _? '{' s:Line+ _? '}' EOL* { return s, nil }

Line <-
    ( _? op:Operation EOL { return op, nil }
    / EOL { return nil, nil }
    )

Operation <-
    ( ConstDef
    / Opcode
    )

ConstDef <-
    ( k:Constant _? '=' _? v:Value {
            if key, ok := k.(string); ok {
                c.state[key] = string(v.([]byte))
                return v, nil
            }
            return nil, errors.New("Bad const def")
        }
    )

Opcode =
    ( "nop" { return newUnitaryOpcode(OpNop) }
    / "drop" { return newUnitaryOpcode(OpDrop) }
    / "push" _? v:Value  { return newPushOpcode(v.(string)) }
    )

Value =
    ( Timestamp
    / Integer
    / ConstantRef
    )

Timestamp <- ts:(Date 'T' Time 'Z') { return newPushTimestamp(ts.(string)) }
Date <- [0-9] [0-9] [0-9] [0-9] '-' [0-9] [0-9] '-' [0-9] [0-9]
Time <-  [0-9] [0-9] ':' [0:9] [0-9] '-' [0-9] [0-9]

ContextConstant <-
    ( "TEST" { return CtxTest, nil }
    / "NODE_PAYOUT" { return CtxNodePayout, nil }
    / "EAI_TIMING" { return CtxEaiTiming, nil }
    / "NODE_QUALITY" { return CtxNodeQuality, nil }
    / "MARKET_PRICE" { return CtxMarketPrice, nil }
    )

ConstantRef <- k:Constant                         { return c.state[k.(string)], nil }
Integer <- '-'? [0-9]+                            { return c.text, nil }
Constant <- [A-Z] [A-Z0-9_]*                      { return string(c.text), nil }

_ <- [ \t]+

EOL <- _? Comment? ("\r\n" / "\n\r" / "\r" / "\n" )

Comment <- ';' [^\r\n]*

EOF <- !.

